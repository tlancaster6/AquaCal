# Task: P.17 Wire up `normal_fixed` config and add normal optimization

## Objective

When `normal_fixed: false` in the YAML config, add 2 interface normal tilt parameters to the Stage 3/4 optimization so the optimizer can estimate the true water surface orientation. Currently, `interface_normal_fixed` is parsed and stored but never passed to the optimizers — the normal is always hardcoded to `[0, 0, -1]`.

## Context Files

Read these files before starting (in order):

1. `src/aquacal/core/refractive_geometry.py` — Current projection functions. `refractive_project_fast()` (line 318) only handles horizontal interfaces. You'll add `refractive_project_general()` here.
2. `src/aquacal/core/interface_model.py` — `Interface` class, `ray_plane_intersection()`. Understand `get_interface_distance()` returns a Z-coordinate (works for horizontal only).
3. `src/aquacal/calibration/_optim_common.py` — Parameter packing, Jacobian sparsity, bounds, and residual computation. This is the core file you'll modify most heavily.
4. `src/aquacal/calibration/interface_estimation.py` — Stage 3 `optimize_interface()`. Currently passes `interface_normal` as fixed in `cost_args`.
5. `src/aquacal/calibration/refinement.py` — Stage 4 `joint_refinement()`. Same pattern as Stage 3.
6. `src/aquacal/calibration/pipeline.py` (lines 380-478) — Pipeline wiring. `interface_normal_fixed` is in config (line 185) but never used downstream.
7. `src/aquacal/config/schema.py` (line 210) — `interface_normal_fixed: bool = True`
8. `tests/unit/test_refractive_geometry.py` — Existing projection tests and test fixtures.
9. `tests/unit/test_interface_estimation.py` — Existing optimization tests and synthetic data generation.

## Modify

Files to create or edit:

- `src/aquacal/core/refractive_geometry.py`
- `src/aquacal/calibration/_optim_common.py`
- `src/aquacal/calibration/interface_estimation.py`
- `src/aquacal/calibration/refinement.py`
- `src/aquacal/calibration/pipeline.py`
- `tests/unit/test_refractive_geometry.py`
- `tests/unit/test_interface_estimation.py`

## Do Not Modify

Everything not listed above. In particular:
- `src/aquacal/config/schema.py` — `interface_normal_fixed` is already there
- `src/aquacal/core/interface_model.py` — Interface class is fine as-is
- `src/aquacal/core/camera.py` — No changes needed
- `tests/synthetic/` — Do not run synthetic pipeline tests

## Design

### Part 1: General Projection Function

Add `refractive_project_general()` to `refractive_geometry.py`.

**Key insight**: For any flat (possibly tilted) interface, the Snell's law problem reduces to the same 1D Newton-Raphson equation as the horizontal case. Instead of using Z-coordinates, use perpendicular distances to the plane.

```python
def refractive_project_general(
    camera: Camera,
    interface: Interface,
    point_3d: Vec3,
    max_iterations: int = 10,
    tolerance: float = 1e-9,
) -> Vec2 | None:
```

**Algorithm:**

1. Compute perpendicular distances from camera C and point Q to the interface plane:
   ```python
   n = interface.normal
   d_cam = interface.get_interface_distance(camera.name)
   # Interface plane point: camera moves d_cam along -n (into water direction)
   p0 = C - d_cam * n

   # Perpendicular distance from camera to plane (should be d_cam)
   h_c = d_cam

   # Perpendicular distance from Q to plane (positive for underwater points)
   h_q = -(np.dot(n, Q - p0))
   ```

2. Compute lateral distance between camera and point projections on the plane:
   ```python
   C_on_plane = p0  # C projected onto interface = p0 by construction
   Q_on_plane = Q - np.dot(n, Q - p0) * n
   lateral = Q_on_plane - C_on_plane
   r_q = np.linalg.norm(lateral)
   ```

3. If `r_q < 1e-10`: point is directly along normal from camera — project `p0` directly.

4. Newton-Raphson (identical equation to `refractive_project_fast`):
   ```python
   r_p = r_q * h_c / (h_c + h_q)  # initial guess (pinhole)
   for _ in range(max_iterations):
       d_air = sqrt(r_p² + h_c²)
       d_water = sqrt((r_q - r_p)² + h_q²)
       f = n_air * r_p / d_air - n_water * (r_q - r_p) / d_water
       f_prime = n_air * h_c² / d_air³ + n_water * h_q² / d_water³
       delta = f / f_prime
       r_p -= delta
       r_p = clamp(0, r_q)
       if abs(delta) < tolerance: break
   ```

5. Compute interface point and project:
   ```python
   lateral_dir = lateral / r_q
   P = C_on_plane + r_p * lateral_dir  # Point on tilted interface plane
   return camera.project(P, apply_distortion=True)
   ```

**Validation checks** (return None if):
- `h_c <= 0` (camera at or below interface)
- `h_q <= 0` (point at or above interface)

For horizontal interfaces, this function should produce **identical** results to `refractive_project_fast()` — the perpendicular distances reduce to the Z-coordinate differences.

**Important**: The `interface_distance` parameter is now interpreted as the **perpendicular distance from camera center to the interface plane along the normal direction**. For a horizontal normal, this is identical to the Z-coordinate interpretation (backward compatible).

### Part 2: Normal Parameterization

Use 2 tilt angles `(tilt_x, tilt_y)` as optimization parameters. Convention: apply `Rx(tilt_x)` then `Ry(tilt_y)` to the default normal `[0, 0, -1]`:

```python
def tilt_to_normal(tilt_x: float, tilt_y: float) -> Vec3:
    """Convert tilt angles to unit normal vector.

    Result: Ry(tilt_y) @ Rx(tilt_x) @ [0, 0, -1]
    For tilt_x=tilt_y=0, returns [0, 0, -1].
    """
    cx, sx = np.cos(tilt_x), np.sin(tilt_x)
    cy, sy = np.cos(tilt_y), np.sin(tilt_y)
    normal = np.array([-sy * cx, sx, -cy * cx])
    return normal / np.linalg.norm(normal)

def normal_to_tilt(normal: Vec3) -> tuple[float, float]:
    """Convert unit normal to tilt angles (inverse of tilt_to_normal)."""
    n = normal / np.linalg.norm(normal)
    tilt_x = np.arcsin(np.clip(n[1], -1.0, 1.0))
    cos_tx = np.cos(tilt_x)
    if abs(cos_tx) < 1e-10:
        tilt_y = 0.0
    else:
        tilt_y = np.arcsin(np.clip(-n[0] / cos_tx, -1.0, 1.0))
    return tilt_x, tilt_y
```

Place these helper functions in `_optim_common.py` (they're optimization-specific, not general geometry).

### Part 3: Parameter Vector Changes (`_optim_common.py`)

**Parameter layout** (normal params appended at the very end when enabled):
```
[cam_extrinsics(6 each) | distances(1 each) | board_poses(6 each) | (intrinsics 4 each) | (normal_tilt 2)]
```

Putting them at the end avoids shifting any existing indices — all current index computations remain unchanged.

#### `pack_params()`

Add `optimize_normal: bool = False` and `interface_normal: Vec3 | None = None` parameters. When `optimize_normal=True`, convert the normal to tilt angles and append 2 values at the end:

```python
if optimize_normal:
    tilt_x, tilt_y = normal_to_tilt(interface_normal)
    params.extend([tilt_x, tilt_y])
```

#### `unpack_params()`

Add `optimize_normal: bool = False` parameter. When True, extract the last 2 elements as tilt angles, convert to normal vector, return as additional element:

```python
# Return type changes to include optional normal
def unpack_params(..., optimize_normal=False) -> tuple[
    dict[str, CameraExtrinsics],
    dict[str, float],
    dict[int, BoardPose],
    dict[str, CameraIntrinsics],
    Vec3 | None,  # NEW: optimized normal, or None
]:
```

When `optimize_normal=True`:
```python
normal = tilt_to_normal(params[idx], params[idx + 1])
idx += 2
```

When `optimize_normal=False`: return `None` for the normal element.

#### `build_jacobian_sparsity()`

Add `optimize_normal: bool = False`. When True, add 2 columns to the sparsity matrix. **Every** residual depends on the normal (the normal affects all projections), so every row gets 1s in the 2 normal columns:

```python
n_normal_params = 2 if optimize_normal else 0
n_params = n_extrinsic_params + n_distance_params + n_pose_params + n_intrinsic_params + n_normal_params

# In the per-corner loop:
if optimize_normal:
    row[n_params - 2 : n_params] = 1
```

#### `build_bounds()`

Add `optimize_normal: bool = False`. When True, append bounds for tilt angles:

```python
if optimize_normal:
    # Allow ±20 degrees tilt (0.35 radians)
    lower = np.append(lower, [-0.35, -0.35])
    upper = np.append(upper, [0.35, 0.35])
```

#### `compute_residuals()`

Add `optimize_normal: bool = False` parameter (after `use_fast_projection`). When True:

1. Extract the normal from the parameter vector (last 2 elements before any processing)
2. Use the extracted normal instead of the passed `interface_normal` argument
3. Use `refractive_project_general()` instead of `refractive_project_fast()` (the general function handles any normal)

```python
if optimize_normal:
    tilt_x, tilt_y = params[-2], params[-1]
    interface_normal = tilt_to_normal(tilt_x, tilt_y)
    # Force general projection (handles tilted normals)
    use_fast_projection = False  # conceptually; actually use refractive_project_general
```

**Critical**: When `optimize_normal=True`, the `unpack_params` call in `compute_residuals` must use `optimize_normal=True` so it knows the last 2 params are normal angles, not part of intrinsics or poses. Update the `unpack_params` call accordingly.

**Projection selection**: When `optimize_normal=True`, call `refractive_project_general()` instead of `refractive_project_fast()` or `refractive_project()`. When `optimize_normal=False`, keep using the existing logic (`refractive_project_fast` if `use_fast_projection` else `refractive_project`). Import `refractive_project_general` at the top of `_optim_common.py`.

#### `make_sparse_jacobian_func()`

No changes needed — it takes the sparsity pattern as input, so the wider matrix from `build_jacobian_sparsity` will flow through automatically.

### Part 4: Optimizer Changes

#### `optimize_interface()` in `interface_estimation.py`

Add `optimize_normal: bool = False` parameter. Changes:

1. Add `optimize_normal` to `cost_args` tuple (append at end)
2. Pass `optimize_normal` to `build_jacobian_sparsity()`, `build_bounds()`, `pack_params()`
3. When calling `pack_params`, pass `interface_normal=interface_normal` and `optimize_normal=optimize_normal`
4. **Return type** changes from 4-tuple to 5-tuple, adding the (possibly optimized) normal:
   ```python
   ) -> tuple[dict[str, CameraExtrinsics], dict[str, float], list[BoardPose], float, Vec3]:
   ```
5. After unpacking the optimized parameters, extract the normal:
   ```python
   opt_ext, opt_dist, opt_poses, _, opt_normal = unpack_params(
       result.x, ..., optimize_normal=optimize_normal
   )
   if opt_normal is None:
       opt_normal = interface_normal  # Fixed normal, return as-is
   ```
6. Return the normal as the 5th element

#### `joint_refinement()` in `refinement.py`

Same pattern. Add `optimize_normal: bool = False`. Return type becomes 6-tuple:
```python
) -> tuple[
    dict[str, CameraExtrinsics],
    dict[str, float],
    list[BoardPose],
    dict[str, CameraIntrinsics],
    float,
    Vec3,  # NEW: optimized normal
]:
```

### Part 5: Pipeline Wiring (`pipeline.py`)

1. **Stage 3 call** (line 424): Add `optimize_normal=not config.interface_normal_fixed`:
   ```python
   stage3_extrinsics, stage3_distances, stage3_poses, stage3_rms, stage3_normal = optimize_interface(
       ...,
       optimize_normal=not config.interface_normal_fixed,
   )
   ```
   Print the optimized normal when it was free:
   ```python
   if not config.interface_normal_fixed:
       tilt_deg = np.degrees(np.arccos(np.clip(-stage3_normal[2], -1, 1)))
       print(f"  Optimized normal: [{stage3_normal[0]:.4f}, {stage3_normal[1]:.4f}, {stage3_normal[2]:.4f}] (tilt: {tilt_deg:.1f}°)")
   ```

2. **Stage 4 call** (line 456): Pass `optimize_normal=not config.interface_normal_fixed`, update unpacking to handle the new return value, use `stage3_normal` as `interface_normal`.

3. **Update `interface_normal` variable**: After Stage 3, replace the hardcoded `interface_normal` with `stage3_normal` for all subsequent usage:
   ```python
   interface_normal = stage3_normal  # May have been optimized
   ```
   This ensures validation, diagnostics, and `InterfaceParams` all use the optimized normal.

4. **`InterfaceParams` construction** (line 513): Already uses `interface_normal`, so it will automatically pick up the optimized value.

5. **`_estimate_validation_poses`** (line 485): Already receives `interface_normal` — no changes needed, it will get the optimized normal.

## Acceptance Criteria

- [ ] `refractive_project_general()` matches `refractive_project_fast()` to within 0.01 px for horizontal interfaces (same test points as `TestRefractiveProjectFast.test_matches_original`)
- [ ] `refractive_project_general()` correctly projects through a 10° tilted interface (round-trip test: project then back-project using general Snell's law should recover original point within 1mm)
- [ ] `refractive_project_general()` returns None for points above the (tilted) interface
- [ ] `optimize_interface(optimize_normal=False)` produces identical results to before (backward compatible). Verify by checking that existing `test_interface_estimation.py` tests still pass.
- [ ] `optimize_interface(optimize_normal=True)` on synthetic data with a 5° tilted normal recovers the true normal within 1° and produces lower RMS than the fixed-normal run
- [ ] Pipeline correctly passes `not config.interface_normal_fixed` to Stage 3 and Stage 4
- [ ] Pipeline prints the optimized normal when `normal_fixed: false`
- [ ] All existing tests pass: `pytest tests/unit/test_refractive_geometry.py tests/unit/test_interface_estimation.py tests/unit/test_refinement.py tests/unit/test_pipeline.py -v`
- [ ] Do NOT run the synthetic pipeline test suite

## Notes

1. **Performance**: `refractive_project_general()` is only marginally slower than `refractive_project_fast()` — same Newton-Raphson solver, just a few extra dot products for the plane geometry. No need to fall back to the slow Brent-search `refractive_project()`.

2. **The perpendicular distance interpretation**: When the interface is tilted, `interface_distance` (from `get_interface_distance()`) is now the perpendicular distance from the camera to the interface plane along the normal. For horizontal interfaces, this equals the Z-coordinate difference, so it's backward compatible.

3. **Jacobian density**: The 2 normal columns in the sparsity matrix are **dense** (every residual depends on the normal). This means the sparse FD approach gets 2 fewer groups to parallelize over. For a typical problem (~50 groups), this is negligible.

4. **Tilt bounds**: ±0.35 radians (±20°) is generous — realistic camera rigs rarely exceed ±10° tilt. The bounds prevent the optimizer from flipping the normal.

5. **Two-phase optimization**: The task does NOT implement a two-phase approach (fixed normal first, then free normal). The optimizer should handle both simultaneously from the initial [0,0,-1] estimate. If convergence is poor in practice, a two-phase approach can be added later.

6. **Test data generation for tilted normal**: To test `optimize_interface(optimize_normal=True)`, generate synthetic detections with a tilted normal:
   - Use `refractive_project_general()` (your new function) to project board corners through a tilted interface
   - Start with the existing `generate_synthetic_detections()` pattern from `test_interface_estimation.py`
   - Set ground truth normal to `tilt_to_normal(np.radians(5), np.radians(3))`

7. **`unpack_params` return type change**: Adding a 5th return element (`Vec3 | None`) is a breaking change. All callers of `unpack_params` must be updated:
   - `compute_residuals()` in `_optim_common.py` — add `_` for the normal
   - `optimize_interface()` in `interface_estimation.py` — capture the normal
   - `joint_refinement()` in `refinement.py` — capture the normal
   - Tests in `test_interface_estimation.py` — update tuple unpacking

## Model Recommendation

**Opus** — Non-trivial changes across 7 files with precise coordinate geometry, optimization parameter management, and backward compatibility requirements. The `refractive_project_general()` derivation and the parameter vector layout changes need careful handling.
