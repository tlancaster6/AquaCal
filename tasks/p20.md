# Task: P.20 Improve 3D Distance Validation Metric

## Objective

Improve `compute_3d_distance_errors()` to use adjacent-only corner distances (single known ground truth), report signed error (bias detection), RMSE, and percent error. Currently it compares all N-choose-2 corner pairs with unsigned error only, which mixes distance scales and hides systematic bias.

## Context Files

Read these files before starting (in order):

1. `src/aquacal/validation/reconstruction.py` — Current implementation. `DistanceErrors` dataclass (line 19), `compute_3d_distance_errors()` (line 84). This is the main file to modify.
2. `src/aquacal/core/board.py` (lines 41-59) — `_compute_corner_positions()` shows corners on a regular grid with spacing `square_size`. Corner IDs: `col = id % (squares_x - 1)`, `row = id // (squares_x - 1)`.
3. `src/aquacal/calibration/pipeline.py` (lines 577-583, 649-655) — How the metric is printed. Update to show new stats.
4. `src/aquacal/validation/diagnostics.py` (lines 282-296) — `generate_recommendations()` thresholds for 3D error. Update to use signed error for scale bias detection.
5. `tests/unit/test_reconstruction.py` — Existing tests.

## Modify

- `src/aquacal/validation/reconstruction.py`
- `src/aquacal/calibration/pipeline.py`
- `src/aquacal/validation/diagnostics.py`
- `tests/unit/test_reconstruction.py`

## Do Not Modify

Everything not listed above. In particular:
- `src/aquacal/config/schema.py` — `DiagnosticsData` stores `validation_3d_error_mean` and `_std` which are fine as-is
- `src/aquacal/core/board.py` — Board geometry is correct
- `src/aquacal/triangulation/triangulate.py` — Triangulation code is correct

## Design

### Part 1: Add Adjacent Pair Helper (`reconstruction.py`)

Add a function to compute adjacent corner pairs from board geometry:

```python
def get_adjacent_corner_pairs(board: BoardGeometry) -> list[tuple[int, int]]:
    """
    Get pairs of adjacent corners on the board (separated by one square_size).

    Adjacent means horizontally or vertically neighboring on the checker grid
    (not diagonal). Each pair appears once with lower ID first.

    Args:
        board: Board geometry

    Returns:
        List of (corner_id_1, corner_id_2) tuples
    """
    cols = board.config.squares_x - 1
    rows = board.config.squares_y - 1
    pairs = []
    for corner_id in range(cols * rows):
        col = corner_id % cols
        row = corner_id // cols
        # Right neighbor
        if col + 1 < cols:
            pairs.append((corner_id, corner_id + 1))
        # Down neighbor
        if row + 1 < rows:
            pairs.append((corner_id, corner_id + cols))
    return pairs
```

### Part 2: Update `DistanceErrors` Dataclass

Add new fields (with defaults for backward compatibility):

```python
@dataclass
class DistanceErrors:
    mean: float              # Mean absolute error (meters) — existing
    std: float               # Std of absolute errors (meters) — existing
    max_error: float         # Max absolute error (meters) — existing
    num_comparisons: int     # Total measurements — existing
    per_corner_pair: dict[tuple[int, int], float] | None = None  # existing

    # New fields
    signed_mean: float = 0.0      # Mean signed error (meters): + = overestimate, - = underestimate
    rmse: float = 0.0             # Root mean squared error (meters)
    percent_error: float = 0.0    # (MAE / ground_truth_distance) * 100
    num_frames: int = 0           # Number of frames with valid measurements
```

### Part 3: Modify `compute_3d_distance_errors()`

Change from all-pairs to **adjacent-only** by default:

```python
def compute_3d_distance_errors(
    calibration: CalibrationResult,
    detections: DetectionResult,
    board: BoardGeometry,
    include_per_pair: bool = False,
) -> DistanceErrors:
```

Key changes inside the function:

1. **Precompute adjacent pairs** at the start:
   ```python
   adjacent_pairs = get_adjacent_corner_pairs(board)
   adjacent_set = set(adjacent_pairs)
   ground_truth_distance = board.config.square_size
   ```

2. **Replace the all-pairs loop** with adjacent-only:
   ```python
   # Instead of:
   #   for i, id1 in enumerate(corner_ids):
   #       for id2 in corner_ids[i+1:]:
   #
   # Use:
   for id1, id2 in adjacent_pairs:
       if id1 in corners_3d and id2 in corners_3d:
           actual_dist = np.linalg.norm(corners_3d[id1] - corners_3d[id2])
           signed_error = actual_dist - ground_truth_distance
           all_signed_errors.append(signed_error)
   ```

3. **Compute new statistics**:
   ```python
   signed_arr = np.array(all_signed_errors)
   abs_arr = np.abs(signed_arr)

   return DistanceErrors(
       mean=float(np.mean(abs_arr)),
       std=float(np.std(abs_arr)),
       max_error=float(np.max(abs_arr)),
       num_comparisons=len(all_signed_errors),
       per_corner_pair=per_pair,
       signed_mean=float(np.mean(signed_arr)),
       rmse=float(np.sqrt(np.mean(signed_arr**2))),
       percent_error=float(np.mean(abs_arr) / ground_truth_distance * 100),
       num_frames=num_frames_with_measurements,
   )
   ```

4. Track `num_frames_with_measurements` — increment a counter for each frame that contributes at least one measurement.

### Part 4: Update Pipeline Output (`pipeline.py`)

Update the print lines (around lines 580-583 and 649-655) to show the richer stats:

```python
if np.isnan(reconstruction_errors.mean):
    print("  WARNING: 3D reconstruction: N/A (no valid comparisons)")
else:
    print(f"  3D distance error: MAE {reconstruction_errors.mean*1000:.2f} mm, "
          f"RMSE {reconstruction_errors.rmse*1000:.2f} mm "
          f"({reconstruction_errors.percent_error:.1f}% of square size)")
    if abs(reconstruction_errors.signed_mean) > 0.0005:  # > 0.5mm bias
        sign = "+" if reconstruction_errors.signed_mean > 0 else ""
        print(f"  Scale bias: {sign}{reconstruction_errors.signed_mean*1000:.2f} mm "
              f"({'overestimate' if reconstruction_errors.signed_mean > 0 else 'underestimate'})")
```

Also update the summary printout at the end of the pipeline (lines 649-655) to match.

### Part 5: Update Diagnostics Recommendations (`diagnostics.py`)

In `generate_recommendations()` (around lines 282-296), add signed error analysis:

```python
# Existing threshold checks...

# NEW: Scale bias detection
if reconstruction.num_comparisons > 0 and abs(reconstruction.signed_mean) > 0.001:
    bias_mm = reconstruction.signed_mean * 1000
    sign = "+" if bias_mm > 0 else ""
    recs.append(
        f"Systematic scale bias detected ({sign}{bias_mm:.1f} mm) — "
        f"{'distances overestimated (check n_water or interface distance)' if bias_mm > 0 else 'distances underestimated'}"
    )
```

Also update `save_diagnostic_report()` JSON output to include the new fields (`signed_mean`, `rmse`, `percent_error`).

## Acceptance Criteria

- [ ] `get_adjacent_corner_pairs()` returns correct pairs for a 6x5 board (should be 31 horizontal + 24 vertical = 55 pairs for a board with 5 cols x 4 rows of corners)
- [ ] `compute_3d_distance_errors()` uses adjacent-only pairs (not all N-choose-2)
- [ ] `DistanceErrors` includes `signed_mean`, `rmse`, `percent_error`, `num_frames`
- [ ] Signed error is positive when triangulated distances are larger than ground truth
- [ ] Pipeline prints MAE, RMSE, percent error, and flags bias > 0.5mm
- [ ] `diagnostics.json` includes new fields
- [ ] `generate_recommendations()` flags systematic scale bias > 1mm
- [ ] Existing tests updated and passing: `pytest tests/unit/test_reconstruction.py tests/unit/test_diagnostics.py tests/unit/test_pipeline.py -v`

## Notes

1. **Why adjacent-only**: With all pairs, a 1% scale error produces 0.3mm error on a 30mm edge but 3mm on a 300mm board diagonal. Mixing these hides the pattern. Adjacent-only gives a clean distribution around a single known distance (`square_size`), making bias immediately visible.

2. **Signed error interpretation**: `signed_mean > 0` means triangulated distances are systematically too long. In a refractive system, this typically indicates `n_water` is too low or interface distances are too large. `signed_mean < 0` suggests the opposite.

3. **Backward compatibility**: New `DistanceErrors` fields have defaults, so existing code that constructs `DistanceErrors` without them won't break. The pipeline reads `.mean` and `.std` which are unchanged in semantics (still absolute error stats).

4. **`per_corner_pair`**: When `include_per_pair=True`, store the signed error (not absolute) per pair. This is a minor semantic change — check if any code relies on it being unsigned (it's currently only used with worst-case tracking, which should use absolute value of the signed error).

## Model Recommendation

**Sonnet** — Focused changes to one metric module plus pipeline printout. No tricky geometry — just changing which pairs are compared and adding signed arithmetic.
