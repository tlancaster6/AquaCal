---
phase: 14-geometry-rewiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquacal/core/_aquakit_bridge.py
autonomous: true

must_haves:
  truths:
    - "Bridge module exists and imports cleanly without touching AquaKit at module load time"
    - "All 5 geometry functions are wrapped with numpy-in / numpy-out signatures matching AquaCal's current API shapes"
    - "_make_interface_params() factory function exists in the bridge so call sites construct AquaKit InterfaceParams without ever naming or importing the AquaKit type directly"
    - "Conversion helpers _to_torch() and _to_numpy() are private to the bridge"
    - "GEOM-01/02/05 (snells_law_3d, trace_ray_air_to_water, ray_plane_intersection) are satisfied transitively via the production path: _bridge_refractive_project → AquaKit internally; the 3 standalone bridge wrappers (_bridge_snells_law_3d, _bridge_trace_ray_air_to_water, _bridge_ray_plane_intersection) serve Phase 16 equivalence testing access, not the production call chain"
  artifacts:
    - path: "src/aquacal/core/_aquakit_bridge.py"
      provides: "Numpy↔torch conversion wrappers for all 5 AquaKit geometry functions plus _make_interface_params factory"
      exports:
        - "_bridge_snells_law_3d"
        - "_bridge_trace_ray_air_to_water"
        - "_bridge_refractive_project"
        - "_bridge_refractive_back_project"
        - "_bridge_ray_plane_intersection"
        - "_make_interface_params"
  key_links:
    - from: "src/aquacal/core/_aquakit_bridge.py"
      to: "aquakit.refraction"
      via: "import aquakit"
      pattern: "import aquakit"
    - from: "_bridge_refractive_project"
      to: "camera.project()"
      via: "two-step: find interface point, then project through Camera"
      pattern: "camera\\.project"
    - from: "call sites (pipeline.py, _optim_common.py, etc.)"
      to: "aquakit.types.InterfaceParams"
      via: "_make_interface_params() factory — call sites never import InterfaceParams by name"
      pattern: "_make_interface_params"
---

<objective>
Create the AquaKit bridge module that centralizes all numpy↔torch conversion and wraps all 5 refractive geometry functions. This is the foundation that all rewiring plans build on.

Purpose: Isolate torch from the rest of AquaCal. When AquaCal eventually migrates to full PyTorch, the conversion layer in this module is removed rather than hunting through call sites. Call sites update once (to call bridge functions); future torch migration touches only the bridge.

Output: `src/aquacal/core/_aquakit_bridge.py`
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-geometry-rewiring/14-CONTEXT.md
@src/aquacal/core/refractive_geometry.py
@src/aquacal/core/interface_model.py
@src/aquacal/core/camera.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AquaKit bridge module</name>
  <files>src/aquacal/core/_aquakit_bridge.py</files>
  <action>
Create `src/aquacal/core/_aquakit_bridge.py` with the following design:

**Module docstring:** "AquaKit geometry bridge — numpy↔torch conversion layer for AquaKit geometry calls."

**Factory function for AquaKit InterfaceParams** — call sites use this instead of importing the AquaKit type directly. This prevents the name collision with AquaCal's own `InterfaceParams` in `aquacal.config.schema`:
```python
def _make_interface_params(water_z: float, n_air: float, n_water: float) -> "aquakit.types.InterfaceParams":
    """Build an AquaKit InterfaceParams for the water surface.

    Call sites use this factory rather than importing aquakit.types.InterfaceParams
    directly, avoiding the name collision with AquaCal's own InterfaceParams type.

    Args:
        water_z: Z-coordinate of the water surface in world frame (meters).
        n_air: Refractive index of air.
        n_water: Refractive index of water.

    Returns:
        AquaKit InterfaceParams with a fixed upward-pointing normal [0, 0, -1].
    """
    from aquakit.types import InterfaceParams as _AquaKitInterfaceParams
    return _AquaKitInterfaceParams(
        normal=torch.tensor([0.0, 0.0, -1.0]),
        water_z=water_z,
        n_air=n_air,
        n_water=n_water,
    )
```

**Private conversion helpers:**
```python
def _to_torch(arr: NDArray[np.float64]) -> torch.Tensor:
    """Convert numpy float64 array to float32 torch tensor."""
    return torch.from_numpy(np.asarray(arr, dtype=np.float32))

def _to_numpy(t: torch.Tensor) -> NDArray[np.float64]:
    """Convert torch tensor to float64 numpy array."""
    return t.detach().cpu().numpy().astype(np.float64)
```

**Bridge functions (implement all 5):**

1. `_bridge_snells_law_3d(incident_direction, surface_normal, n_ratio)`:
   - AquaCal's current `snells_law_3d` takes a single Vec3 incident direction and returns `Vec3 | None`.
   - Bridge input: single numpy Vec3 `incident_direction` (shape (3,)), numpy Vec3 `surface_normal`, float `n_ratio`.
   - Convert to torch: `incident_t = _to_torch(incident_direction).unsqueeze(0)` (shape (1, 3)), `normal_t = _to_torch(surface_normal)`.
   - Call: `dirs, valid = aquakit.snells_law_3d(incident_t, normal_t, n_ratio)`.
   - Return: `_to_numpy(dirs[0])` if `valid[0].item()` else `None`. This matches the original API (Vec3 or None for TIR).

2. `_bridge_trace_ray_air_to_water(camera, interface_aq, pixel)`:
   - AquaCal's current `trace_ray_air_to_water` takes `(Camera, Interface, pixel)` and returns `(Vec3, Vec3) | (None, None)`.
   - Bridge accepts: `camera: Camera` (AquaCal), `interface_aq: InterfaceParams`, `pixel: Vec2`.
   - Inside bridge: call `camera.pixel_to_ray_world(pixel)` to get `(ray_origin, ray_direction)` as numpy arrays.
   - Convert: `origins_t = _to_torch(ray_origin).unsqueeze(0)`, `dirs_t = _to_torch(ray_direction).unsqueeze(0)`.
   - Call: `ipts, rdirs, valid = aquakit.trace_ray_air_to_water(origins_t, dirs_t, interface_aq)`.
   - Return: `(_to_numpy(ipts[0]), _to_numpy(rdirs[0]))` if `valid[0].item()` else `(None, None)`.

3. `_bridge_refractive_project(camera, interface_aq, point_3d)`:
   - AquaCal's current `refractive_project` takes `(Camera, Interface, Vec3)` and returns `Vec2 | None`.
   - Bridge is a TWO-STEP process:
     - Step 1 — find interface point: `points_t = _to_torch(np.asarray(point_3d)).unsqueeze(0)`, `cam_center_t = _to_torch(camera.C)`, then call `ipts, valid = aquakit.refractive_project(points_t, cam_center_t, interface_aq)`.
     - Step 2 — project interface point through camera: if `valid[0].item()`, call `camera.project(_to_numpy(ipts[0]), apply_distortion=True)`. Return that result, or None if camera.project returns None.
     - Return None if `not valid[0].item()`.
   - Note: AquaKit's `refractive_project` returns interface points (not pixels). The camera.project() call is the AquaCal-specific second step.

4. `_bridge_refractive_back_project(camera, interface_aq, pixel)`:
   - AquaCal's current `refractive_back_project` takes `(Camera, Interface, pixel)` and returns `(Vec3, Vec3) | (None, None)`.
   - Inside bridge: call `camera.pixel_to_ray_world(pixel)` to get `(ray_origin, ray_direction)` as numpy.
   - Convert: `pixel_rays_t = _to_torch(ray_direction).unsqueeze(0)`, `cam_centers_t = _to_torch(ray_origin).unsqueeze(0)`.
   - Call: `ipts, wdirs, valid = aquakit.refractive_back_project(pixel_rays_t, cam_centers_t, interface_aq)`.
   - Return: `(_to_numpy(ipts[0]), _to_numpy(wdirs[0]))` if `valid[0].item()` else `(None, None)`.

5. `_bridge_ray_plane_intersection(ray_origin, ray_direction, plane_point, plane_normal)`:
   - AquaCal's current `ray_plane_intersection` takes numpy Vec3 args and returns `(Vec3, float) | (None, None)`.
   - AquaKit's `ray_plane_intersection` takes `(origins, directions, plane_normal, plane_d: float)`.
   - Compute `plane_d = float(np.dot(plane_point, plane_normal))` to convert from point+normal form to scalar form.
   - Convert: `origins_t = _to_torch(ray_origin).unsqueeze(0)`, `dirs_t = _to_torch(ray_direction).unsqueeze(0)`, `pn_t = _to_torch(plane_normal)`.
   - Call: `pts, valid = aquakit.ray_plane_intersection(origins_t, dirs_t, pn_t, plane_d)`.
   - Compute t: `t = float(np.dot(_to_numpy(pts[0]) - ray_origin, ray_direction) / max(np.dot(ray_direction, ray_direction), 1e-30))`.
   - Return: `(_to_numpy(pts[0]), t)` if `valid[0].item()` else `(None, None)`.

**Imports section** (at top of file):
```python
import numpy as np
import torch
from numpy.typing import NDArray

import aquakit

from aquacal.config.schema import Vec2, Vec3
from aquacal.core.camera import Camera
```

Note: `aquakit.types.InterfaceParams` is intentionally NOT imported at module level and NOT re-exported by name. Call sites must use `_make_interface_params()` factory instead. This avoids the name collision with AquaCal's own `InterfaceParams` in `aquacal.config.schema`.

**`__all__`** should list all public bridge functions and `_make_interface_params`. Do NOT include `InterfaceParams` in `__all__`.

Each bridge function must have a Google-style docstring with Args, Returns, and a note that it converts numpy↔torch internally.
  </action>
  <verify>
Run: `python -c "from aquacal.core._aquakit_bridge import _bridge_snells_law_3d, _bridge_refractive_project, _make_interface_params; print('bridge imports OK')" 2>&1`

Expected: "bridge imports OK" (aquakit will import torch; if torch isn't installed locally this will fail — that is expected behavior per Phase 13. In CI torch is installed.)

Run: `python -c "from aquacal.core._aquakit_bridge import InterfaceParams" 2>&1`
Expected: ImportError (InterfaceParams must NOT be a module-level export from the bridge).

Also run: `python -m ruff check src/aquacal/core/_aquakit_bridge.py` to confirm no lint errors.
  </verify>
  <done>
`src/aquacal/core/_aquakit_bridge.py` exists with all 5 bridge functions and `_make_interface_params` factory. `InterfaceParams` is NOT in `__all__` and NOT importable directly from the bridge. Each function has a Google-style docstring, correct type hints, and matches the AquaCal numpy API for its inputs and outputs. Ruff passes with no errors.
  </done>
</task>

</tasks>

<verification>
- Bridge module exists at `src/aquacal/core/_aquakit_bridge.py`
- All 5 bridge functions present: `_bridge_snells_law_3d`, `_bridge_trace_ray_air_to_water`, `_bridge_refractive_project`, `_bridge_refractive_back_project`, `_bridge_ray_plane_intersection`
- `_make_interface_params(water_z, n_air, n_water)` factory function present and callable
- `InterfaceParams` is NOT in `__all__` and NOT importable as `from aquacal.core._aquakit_bridge import InterfaceParams`
- `_to_torch` and `_to_numpy` are private (prefixed with `_`)
- `__all__` lists bridge functions and `_make_interface_params` (no bare `InterfaceParams`)
- File has module docstring
- `python -m ruff check src/aquacal/core/_aquakit_bridge.py` passes
</verification>

<success_criteria>
Bridge module created and importable. All 5 wrapper functions present with correct numpy-in/numpy-out signatures. `_make_interface_params()` factory is the single access point for constructing AquaKit InterfaceParams. No bare `InterfaceParams` re-export. Ruff clean.
</success_criteria>

<output>
After completion, create `.planning/phases/14-geometry-rewiring/14-01-SUMMARY.md`
</output>
