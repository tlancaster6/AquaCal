---
phase: 02-ci-cd-automation
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - .github/workflows/docs.yml
  - .github/workflows/publish.yml
  - .github/workflows/release.yml
  - pyproject.toml
  - docs/conf.py
  - docs/index.rst
  - docs/Makefile
  - docs/make.bat
autonomous: true
user_setup:
  - service: pypi
    why: "Trusted Publishing requires OIDC configuration on PyPI before first publish"
    env_vars: []
    dashboard_config:
      - task: "Create pending Trusted Publisher on PyPI"
        location: "PyPI -> Your projects -> aquacal -> Publishing -> Add a new pending publisher (or manage existing). Set: repository owner=tlancaster6, repository name=AquaCal, workflow name=publish.yml, environment name=pypi"
  - service: github
    why: "GitHub environment 'pypi' needed for publish workflow protection"
    env_vars: []
    dashboard_config:
      - task: "Create 'pypi' environment in GitHub repo settings"
        location: "GitHub -> Settings -> Environments -> New environment -> name: pypi"
  - service: codecov
    why: "Coverage reporting on PRs"
    env_vars:
      - name: CODECOV_TOKEN
        source: "Codecov.io -> Settings -> General -> Upload Token (add as GitHub repo secret)"
    dashboard_config:
      - task: "Enable repository on Codecov"
        location: "Codecov.io -> Add new repository -> select AquaCal"

must_haves:
  truths:
    - "Sphinx documentation builds in CI on PRs to catch doc errors before merge"
    - "PyPI publish triggers on git tag push with test gate before publishing"
    - "Trusted Publishing uses OIDC (no API tokens) with id-token: write only on publish job"
    - "Minimal Sphinx docs setup exists so docs.yml has something to build"
    - "Semantic release automates version bumping and tag creation on merge to main"
  artifacts:
    - path: ".github/workflows/docs.yml"
      provides: "Sphinx doc build validation on PR"
      contains: "sphinx"
    - path: ".github/workflows/publish.yml"
      provides: "PyPI Trusted Publishing workflow with test gate"
      contains: "pypa/gh-action-pypi-publish"
    - path: ".github/workflows/release.yml"
      provides: "Automated version bumping and tag creation via semantic release"
      contains: "semantic-release"
    - path: "docs/conf.py"
      provides: "Minimal Sphinx configuration"
      contains: "aquacal"
    - path: "docs/index.rst"
      provides: "Documentation root page"
      contains: "toctree"
  key_links:
    - from: ".github/workflows/publish.yml"
      to: "pyproject.toml"
      via: "python -m build reads package metadata"
      pattern: "python -m build"
    - from: ".github/workflows/release.yml"
      to: "pyproject.toml"
      via: "semantic-release reads version and config from pyproject.toml"
      pattern: "tool\\.semantic_release"
    - from: ".github/workflows/release.yml"
      to: ".github/workflows/publish.yml"
      via: "semantic-release pushes v* tag which triggers publish.yml"
      pattern: "v\\*"
    - from: ".github/workflows/docs.yml"
      to: "docs/conf.py"
      via: "sphinx-build reads conf.py"
      pattern: "sphinx-build\\|make html"
---

<objective>
Create docs.yml workflow for Sphinx doc build validation, publish.yml for PyPI Trusted Publishing, release.yml for automated semantic versioning, and minimal Sphinx docs scaffolding.

Purpose: docs.yml catches documentation build errors before merge. publish.yml enables automated PyPI releases on git tag with test safety gate. release.yml automates version bumping and tag creation using python-semantic-release so tags don't need manual creation. Minimal docs/ setup gives docs.yml something to build (full documentation content comes in Phase 5).
Output: Three workflow files, semantic release config in pyproject.toml, and minimal docs/ directory
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ci-cd-automation/02-RESEARCH.md
@.planning/phases/02-ci-cd-automation/02-01-SUMMARY.md
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docs.yml workflow and minimal Sphinx scaffolding</name>
  <files>
    .github/workflows/docs.yml
    docs/conf.py
    docs/index.rst
    docs/Makefile
    docs/make.bat
  </files>
  <action>
**1. Create minimal Sphinx scaffolding in `docs/`:**

`docs/conf.py`:
```python
project = "AquaCal"
copyright = "2024, Tucker Lancaster"
author = "Tucker Lancaster"
extensions = ["sphinx.ext.autodoc", "sphinx.ext.napoleon"]
templates_path = ["_templates"]
exclude_patterns = ["_build"]
html_theme = "sphinx_rtd_theme"
```

`docs/index.rst`:
```rst
AquaCal Documentation
=====================

.. toctree::
   :maxdepth: 2
   :caption: Contents:

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
```

`docs/Makefile` (standard Sphinx Makefile with SPHINXBUILD, SOURCEDIR, BUILDDIR).

`docs/make.bat` (standard Sphinx make.bat for Windows).

This is a MINIMAL scaffold -- Phase 5 will add real content. The purpose here is to give docs.yml something to successfully build.

**2. Create `.github/workflows/docs.yml`:**

- Trigger: pull_request to main only (no push trigger)
- Job: build-docs on ubuntu-latest
- Steps:
  1. actions/checkout@v4
  2. actions/setup-python@v5 with python-version: '3.12', cache: 'pip', cache-dependency-path: 'pyproject.toml'
  3. Install: `python -m pip install --upgrade pip` then `pip install -e ".[dev]"` then `pip install sphinx sphinx-rtd-theme`
  4. Build docs: `sphinx-build -W --keep-going -b html docs docs/_build/html`
     - `-W` treats warnings as errors (catches broken refs)
     - `--keep-going` shows ALL warnings before failing (not just first)
     - Using `sphinx-build` directly instead of `make html` for consistency across platforms

Do NOT add sphinx/sphinx-rtd-theme to pyproject.toml dev deps yet -- that's a Phase 5 concern. The CI workflow installs them explicitly.
  </action>
  <verify>Validate YAML: `python -c "import yaml; yaml.safe_load(open('.github/workflows/docs.yml'))"`. Confirm docs/conf.py exists and imports correctly: `python -c "exec(open('docs/conf.py').read()); print(project)"`. Confirm docs/index.rst exists. Confirm docs.yml trigger is pull_request only (no push).</verify>
  <done>docs.yml validates Sphinx build on PRs with -W flag. Minimal docs/ scaffolding (conf.py, index.rst, Makefile, make.bat) exists for CI to build against.</done>
</task>

<task type="auto">
  <name>Task 2: Create publish.yml with Trusted Publishing and test gate</name>
  <files>.github/workflows/publish.yml</files>
  <action>
Create `.github/workflows/publish.yml` with three jobs: test, build, publish.

- Trigger: push tags matching `v*` (e.g., v1.0.0)

**test job:**
- runs-on: ubuntu-latest
- Steps:
  1. actions/checkout@v4
  2. actions/setup-python@v5 with python-version: '3.12', cache: 'pip', cache-dependency-path: 'pyproject.toml'
  3. Install: `python -m pip install --upgrade pip` then `pip install -e ".[dev]"`
  4. Run fast tests: `pytest tests/ -m "not slow"`

**build job:**
- needs: test (tests must pass before building)
- runs-on: ubuntu-latest
- Steps:
  1. actions/checkout@v4
  2. actions/setup-python@v5 with python-version: '3.12'
  3. Install build tool: `python -m pip install --upgrade pip build`
  4. Build: `python -m build`
  5. Upload artifact: actions/upload-artifact@v4 with name: dist, path: dist/

**publish job:**
- needs: build (build must succeed before publishing)
- runs-on: ubuntu-latest
- environment: pypi (matches PyPI Trusted Publisher config)
- permissions: id-token: write (ONLY on this job -- principle of least privilege)
- Steps:
  1. actions/download-artifact@v4 with name: dist, path: dist/
  2. pypa/gh-action-pypi-publish@release/v1 (NO username/password/token -- OIDC handles auth)

CRITICAL: id-token: write permission ONLY on publish job, NOT at workflow level. Do NOT add any secrets for PyPI auth.

Per user decision: tests must pass before publish, even though main should be green.
  </action>
  <verify>Validate YAML: `python -c "import yaml; d=yaml.safe_load(open('.github/workflows/publish.yml')); jobs=list(d['jobs'].keys()); print(jobs); print(d['jobs']['publish'].get('permissions',{})); print(d['jobs']['publish'].get('environment',''))"`. Confirm three jobs (test, build, publish). Confirm publish has id-token: write and environment: pypi. Confirm build needs test, publish needs build. Confirm NO secrets/tokens for PyPI.</verify>
  <done>publish.yml triggers on v* tags, runs tests first, builds package, then publishes to PyPI via Trusted Publishing (OIDC) with id-token: write scoped only to publish job</done>
</task>

<task type="auto">
  <name>Task 3: Create release.yml workflow and semantic release config</name>
  <files>
    .github/workflows/release.yml
    pyproject.toml
  </files>
  <action>
**1. Add python-semantic-release to dev dependencies in pyproject.toml** (append to the dev list that Plan 02-01 already updated).

**2. Add semantic release configuration to pyproject.toml:**

```toml
[tool.semantic_release]
version_toml = ["pyproject.toml:project.version"]
branch = "main"
commit_message = "chore(release): {version}"
build_command = "python -m build"
tag_format = "v{version}"

[tool.semantic_release.commit_parser_options]
allowed_tags = ["build", "chore", "ci", "docs", "feat", "fix", "perf", "refactor", "style", "test"]
minor_tags = ["feat"]
patch_tags = ["fix", "perf"]

[tool.semantic_release.remote.token]
env = "GH_TOKEN"
```

Key config choices:
- `version_toml` points at pyproject.toml's `project.version` field — single source of truth
- `tag_format = "v{version}"` produces tags like `v1.0.0` that match publish.yml's `v*` trigger
- Conventional commits: `feat` → minor bump, `fix`/`perf` → patch bump, `BREAKING CHANGE` in footer → major bump
- `build_command` builds the package so semantic-release can include dist in GitHub Release assets

**3. Create `.github/workflows/release.yml`:**

```yaml
name: Release

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    # Only run if NOT a release commit (prevent infinite loop)
    if: "!startsWith(github.event.head_commit.message, 'chore(release):')"

    permissions:
      contents: write  # Push tags, create GitHub Releases
      id-token: write   # Needed if publish job is chained (not used here directly)

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for commit analysis
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'pyproject.toml'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install python-semantic-release

      - name: Run semantic release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: semantic-release version --no-push && semantic-release publish
```

Wait — simpler approach. Use the `python-semantic-release` GitHub Action directly:

```yaml
name: Release

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!startsWith(github.event.head_commit.message, 'chore(release):')"
    concurrency: release

    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install python-semantic-release
        run: pip install python-semantic-release

      - name: Semantic release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          semantic-release version
```

CRITICAL details:
- `fetch-depth: 0` — semantic-release needs full git history to analyze commits
- `if: "!startsWith(..."` — prevents infinite loop when semantic-release pushes its own commit
- `concurrency: release` — prevents parallel release runs on rapid merges
- `permissions: contents: write` — needed to push tags and create GitHub Releases
- `GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}` — default GitHub token, no extra secrets needed
- `semantic-release version` analyzes commits since last tag, bumps version in pyproject.toml, commits, tags, and pushes. If no releasable commits, it exits cleanly with no changes.
- The pushed `v*` tag then triggers `publish.yml` automatically

Flow: merge PR → release.yml → semantic-release analyzes → bumps version + pushes tag → publish.yml → tests → build → publish to PyPI
  </action>
  <verify>Validate YAML: `python -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))"`. Confirm trigger is push to main. Confirm `fetch-depth: 0` is set. Confirm the infinite-loop guard `if` condition exists. Confirm `python -c "import tomllib; d=tomllib.load(open('pyproject.toml','rb')); print(d['tool']['semantic_release'])"` shows semantic release config with version_toml and tag_format.</verify>
  <done>release.yml runs on push to main, uses python-semantic-release to analyze conventional commits, bumps version and creates v* tags that trigger publish.yml. Config in pyproject.toml points at project.version as single source of truth.</done>
</task>

</tasks>

<verification>
- .github/workflows/docs.yml exists with valid YAML, triggers on PR only
- .github/workflows/publish.yml exists with valid YAML, triggers on v* tags
- .github/workflows/release.yml exists with valid YAML, triggers on push to main
- release.yml has infinite-loop guard and fetch-depth: 0
- publish.yml has 3 jobs with correct dependency chain (test -> build -> publish)
- publish.yml id-token: write is job-level only (not workflow-level)
- pyproject.toml has [tool.semantic_release] with version_toml and tag_format = "v{version}"
- docs/ directory has conf.py, index.rst, Makefile, make.bat
- Sphinx build would succeed locally: `sphinx-build -b html docs docs/_build/html`
</verification>

<success_criteria>
- docs.yml catches Sphinx build errors on PRs with -W flag
- publish.yml publishes to PyPI on tag via Trusted Publishing with test gate
- release.yml automates version bumping and tag creation via conventional commits
- Minimal docs scaffolding exists for CI validation
- No API tokens or secrets used for PyPI authentication
- Semantic release config uses pyproject.toml version as single source of truth
</success_criteria>

<output>
After completion, create `.planning/phases/02-ci-cd-automation/02-03-SUMMARY.md`
</output>
